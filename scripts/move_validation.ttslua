--these functions check if the move being made is valid. They are also used by hint_markers to show legal moves

function checkFigurePlacement(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false

    if lastDroppedObject_GUID == nil then return end
    --for some reason it is possible to get into a state where the lastDroppedObject is never resting. it therefore will go into an infinite loop waiting for this state
    --if lastDroppedObject.resting then
    local newFigure = getObjectFromGUID(lastDroppedObject_GUID)
    if newFigure == nil then return end --makes sure object still exists

    if newFigure.held_by_color ~= nil then
        allErrorMessage({"MESSAGE_FIGURE_PICKED_UP"}, activePlayers[currentMiniTurn])
        return
    end

    if turnState == 'awaiting phantom decision' and newFigure.getVar('figureName') ~= 'Phantom' then
        allErrorMessage({"Error: You are only allowed to place the phantom at this time."}, activePlayers[currentPlayer])
        return
    end

    local xIndex, zIndex, xPosition, zPosition = getFigureTileLocation(newFigure)
    if not tileGridOccupied(xIndex, zIndex) then
        --allErrorMessage("Invalid Location: Figure was not placed on a tile", activePlayers[currentPlayer])
        return
    end

    local closestFeatureMapPosition = findClosestPosition(xIndex, zIndex, xPosition, zPosition)

    local featureNum = getFeatureNumAt(xIndex, zIndex, closestFeatureMapPosition)
    if featureNum == nil then
        allErrorMessage({"MESSAGE_INVALID_LOCATION_MIDDLE"}, activePlayers[currentPlayer])
        return
    end
    local nameOfFeature = featureList[featureNum].nameOfFeature

    if turnState == 'awaiting figure decision' or turnState == 'awaiting phantom decision' then
        if lastPlacedTileX == nil or lastPlacedTileZ == nil then
            allErrorMessage({"MESSAGE_FIGURE_PLACED_BEFORE_TILE"}, activePlayers[currentPlayer])
            return
        end
        if newFigure.getVar('figureName') == 'Fairy' then
            local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
            for _, follower in ipairs(objs) do
                if follower.getVar('owner') == activePlayers[currentPlayer] and table.contains(FOLLOWER_TYPES, follower.getVar('figureName')) then
                    local followerXIndex, followerZIndex, _, _ = getFigureTileLocation(follower)
                    if xIndex == followerXIndex and
                     zIndex == followerZIndex then
                        if AUTOLOCK then
                           newFigure.setLock(true)
                        end
                        return nextState('placed fairy')
                    end
                end
            end
            allErrorMessage({"MESSAGE_INVALID_LOCATION_FAIRY"}, activePlayers[currentPlayer])
            return
        end

        getActiveFigures()

        if not isValidFigureLocation(newFigure, xIndex, zIndex, closestFeatureMapPosition, featureNum, true) then return end

        if string.sub(nameOfFeature,1,6) == 'Flier-' then
            flierCheckPlacement(newFigure, xIndex, zIndex, nameOfFeature)
            return nextState('placed flier')
        end
        if newFigure.getVar('figureName') == 'Tower' then
            towerFigurePlacement(newFigure, xIndex, zIndex, closestFeatureMapPosition)
            return nextState('placed tower')
        end
        if nameOfFeature == 'Tower Foundation' then
            nameOfFeature = 'a tower'
        end
        if table.contains(CLOISTER_FEATURES, nameOfFeature) then
            local challengerTile, challengedTile
            if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                challengerTile = 'Cloister'
                challengedTile = 'Shrine'
            else
                challengerTile = 'Shrine'
                challengedTile = 'Cloister'
            end
            for x=-1, 1 do
                for z=-1, 1 do
                    if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                        local specialFeatures = getTileDataForTile(getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid)).specialFeatures
                        if specialFeatures ~= nil then
                            for specialFeatureNum, feature in ipairs(specialFeatures) do
                                local adjacentFeature = feature[1]
                                if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                if adjacentFeature == challengedTile then
                                    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                                    for _, object in ipairs(objs) do
                                        if table.contains(FOLLOWER_TYPES, object.getVar('figureName')) then
                                            local objectXIndex, objectZIndex, xPosition, zPosition = getFigureTileLocation(object)
                                            if objectXIndex == xIndex + x and objectZIndex == zIndex + z then
                                                local nestedClosestFeatureMapPosition = findClosestPosition(xIndex + x, zIndex + z, xPosition, zPosition)
                                                if nestedClosestFeatureMapPosition == specialFeatureNum + 12 then
                                                    allGameMessage({"MESSAGE_SHRINE_CHALLENGED", {'{c1}', object.getDescription()}, {'{f1}', object.getName()}, {'{s2}', translate({feature[1]})}}, player_color_tints[object.getVar('owner')])
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        if newFigure.getVar('figureName') == 'Barn' then
            AnMSetNewBarn(newFigure)
        end
    elseif turnState == 'replace finished wagons' then
        if currentMiniTurn == nil then return end
        if not AnMCheckReplaceFinishedWagons(newFigure, featureNum, activePlayers[currentMiniTurn]) then
            return
        end
    elseif turnState == 'awaiting flier decision' or turnState == 'awaiting flier decision - phantom' then
        if not flierIsLastDroppedObject() then
            allErrorMessage({"MESSAGE_FLIER_WRONG_FIGURE"}, activePlayers[currentPlayer])
            return
        end
        if not flierIsValidFlierLocationOffset(xIndex, zIndex) then
            allErrorMessage({"MESSAGE_INVALID_LOCATION_FLIER_WRONG_TILE"}, activePlayers[currentPlayer])
            return
        end
        if not flierisValidLocation(newFigure, featureNum, true) then return end
        if table.contains(CLOISTER_FEATURES, nameOfFeature) then
            local challengerTile, challengedTile
            if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                challengerTile = 'Cloister'
                challengedTile = 'Shrine'
            else
                challengerTile = 'Shrine'
                challengedTile = 'Cloister'
            end
            for x=-1, 1 do
                for z=-1, 1 do
                    if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                        local specialFeatures = getTileDataForTile(getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid)).specialFeatures
                        if specialFeatures ~= nil then
                            for specialFeatureNum, feature in ipairs(specialFeatures) do
                                local adjacentFeature = feature[1]
                                if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                if adjacentFeature == challengedTile then
                                    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                                    for _, object in ipairs(objs) do
                                        if table.contains(FOLLOWER_TYPES, object.getVar('figureName')) then
                                            local objectXIndex, objectZIndex, xPosition, zPosition = getFigureTileLocation(object)
                                            if objectXIndex == xIndex + x and objectZIndex == zIndex + z then
                                                local nestedClosestTilePosition = findClosestTilePosition(xIndex + x, zIndex + z, xPosition, zPosition)
                                                if nestedClosestTilePosition == specialFeatureNum + 12 then
                                                    allGameMessage({"MESSAGE_SHRINE_CHALLENGED", {'{c1}', object.getDescription()}, {'{f1}', object.getName()}, {'{s2}', translate({feature[1]})}}, player_color_tints[object.getVar('owner')])
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    elseif turnState == 'prompt moving to carcassonne' then
        if not isValidCoCLocation(newFigure, featureNum, true) then return end
    elseif turnState == 'prompt moving from carcassonne' or turnState == 'game over - prompt moving from carcassonne' then
        if not isValidLocationFromCoC(newFigure, featureNum, true) then return end
        carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] = nil
        newFigure.highlightOff()
        for follower_guid, quarter in pairs(carcassonneFigures[activePlayers[currentMiniTurn]]) do
            getObjectFromGUID(follower_guid).highlightOff()
            getObjectFromGUID(follower_guid).setLock(true)
        end
        if turnState == 'prompt moving from carcassonne' then
            currentMiniTurn = currentMiniTurn + 1
        end
    end

    if AUTOLOCK then
        newFigure.setLock(true)
    end

    if newFigure.getVar('figureName') == 'Count' then
        allGameMessage({"MESSAGE_COUNT_PLACED", {'{f1}', newFigure.getName()}, {'{s2}', translate({nameOfFeature})}}, newFigure.getColorTint())
    else
        allGameMessage({"MESSAGE_FIGURE_PLACED", {'{c1}', newFigure.getDescription()}, {'{f1}', newFigure.getName()}, {'{s2}', translate({nameOfFeature})}}, player_color_tints[newFigure.getVar('owner')])
    end

    local yawRotation, pitchRotation

    if newFigure.getVar('figureName') == 'Barn' then --don't rotate the barn
        yawRotation = newFigure.getRotation().y
    else
        yawRotation = getPositionYawRotation(closestFeatureMapPosition, newFigure.getRotation().y)
    end

    if table.contains(MEEPLE_TYPES, newFigure.getVar('figureName')) and nameOfFeature == 'Field' then
        --lay the Follower down
        pitchRotation = 90
    else
        --align with the tile
        pitchRotation = 0
    end

    newFigure.setRotation({pitchRotation, yawRotation, 0})

    clearArbitraryButtons() --TODO: is this needed? I took this from the wagon portion
    if newFigure.getVar('figureName') == 'Shepherd' then
        HaSSetShepard(newFigure.getGUID())
        return nextState('placed shepherd')
    elseif turnState == 'awaiting flier decision' or turnState == 'awaiting flier decision - phantom' then
        return nextState('placed flier')
    else
        if turnState == 'awaiting figure decision' and (xIndex ~= lastPlacedTileX or zIndex ~= lastPlacedTileZ) then
            PnDSetAlreadyUsedMagicPortal(true)
        end
        riverFigurePlacement(newFigure, tileGrid[xIndex][zIndex])
        return nextState('placed figure')
    end
end

--ensure this tile is valid for this location
function checkTile(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID == nil then return end --makes sure object still exists
        --for some reason it is possible to get into a state where the lastDroppedObject is never resting. it therefore will go into an infinite loop waiting for this state
        --if lastDroppedObject.resting then
    local newTile = getObjectFromGUID(lastDroppedObject_GUID)
    if newTile == nil or newTile.held_by_color ~= nil then
        allErrorMessage({"MESSAGE_TILE_PICKED_UP"}, activePlayers[currentPlayer])
        return
    end
    local newTileData = getTileDataForTile(newTile)
    if newTileData.sides == nil then
        allErrorMessage({"MESSAGE_ERROR_NO_SCRIPT_DATA"})
        return
    end
    local xPosition = (newTile.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
    local zPosition = (newTile.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
    local yRotation = newTile.getRotation().y / 90
    --debugMessage(3, "piece rotation: " .. yRotation .. " piece position: x: " .. xPosition .. " z: " .. zPosition)
    if isWithinErrorMargin(xPosition, math.floor(xPosition + TILE_PLACEMENT_MARGIN * TILE_SPACING), TILE_PLACEMENT_MARGIN * TILE_SPACING) and
    isWithinErrorMargin(zPosition, math.floor(zPosition + TILE_PLACEMENT_MARGIN * TILE_SPACING), TILE_PLACEMENT_MARGIN * TILE_SPACING) and
    isWithinErrorMargin(yRotation, math.floor(yRotation + TILE_PLACEMENT_MARGIN), TILE_PLACEMENT_MARGIN) and
    (isWithinErrorMargin(0, newTile.getRotation().x, TILE_PLACEMENT_MARGIN * 90) or
    isWithinErrorMargin(360, newTile.getRotation().x, TILE_PLACEMENT_MARGIN * 90)) and
    (isWithinErrorMargin(0, newTile.getRotation().z, TILE_PLACEMENT_MARGIN * 90) or
    isWithinErrorMargin(360, newTile.getRotation().z, TILE_PLACEMENT_MARGIN * 90)) then
        local xIndex = math.floor(xPosition + TILE_PLACEMENT_MARGIN * TILE_SPACING)
        local zIndex = math.floor(zPosition + TILE_PLACEMENT_MARGIN * TILE_SPACING)
        --by adding 0.5, getting the floor will round to the nearest whole number
        local tileRotation = math.floor(yRotation + 0.5)
        if tileRotation == 0 then tileRotation = 4 end
        --debugMessage(2, "piece rotation: " .. tileRotation .. " piece indexes: x: " .. xIndex .. " z: " .. zIndex)
        if isValidTileLocation(newTile, tileRotation, xIndex, zIndex, true) then
            newTile.setPosition({xIndex * TILE_SPACING - MIDDLE_OFFSET.x, TABLE_SURFACE_Y, zIndex * TILE_SPACING - MIDDLE_OFFSET.z})
            newTile.setRotation({0, tileRotation * 90, 0})

            if AUTOLOCK then
                newTile.setLock(true)
            end
            addTile(xIndex, zIndex, newTile, tileRotation, false, false)
            return nextState('tile placed')
        end
    else
        allErrorMessage({"MESSAGE_INVALID_LOCATION_TILE_NOT_ALIGNED"}, activePlayers[currentPlayer])
    end
end

function isTileInPlay()
    if tileInPlay == nil then
        for nestedX, featureColumn in pairs(tileGrid) do
            for nestedZ, _ in pairs(featureColumn) do
                tileInPlay = true
                break
            end
        end
    end
    return tileInPlay
end

function isValidTileLocation(tile, tileRotation, xIndex, zIndex, verbose)
    local tileData = getTileDataForTile(tile)
    if tileGridOccupied(xIndex, zIndex) then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_TILE_LOCATION_TAKEN"}, activePlayers[currentPlayer]) end
        return false
    end
    if not (not isTileInPlay() or
    tileGridOccupied(xIndex + 1, zIndex) or tileGridOccupied(xIndex - 1, zIndex) or
    tileGridOccupied(xIndex, zIndex + 1) or tileGridOccupied(xIndex, zIndex - 1)) then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_TILE_NOT_ADJACENT"}, activePlayers[currentPlayer]) end
        return false
    end
    if not (xIndex >= MIN_X and xIndex <= MAX_X and zIndex >= MIN_Z and zIndex <= MAX_Z) then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_TILE_OUT_OF_BOUNDS"}, activePlayers[currentPlayer]) end
        return false
    end
    if not ((not tileGridOccupied(xIndex + 1, zIndex) or tileConnectsToSide(tile, tileRotation, 4, getObjectFromGUID(tileGrid[xIndex + 1][zIndex].tile_guid), tileGrid[xIndex + 1][zIndex].rotation)) and
    (not tileGridOccupied(xIndex - 1, zIndex) or tileConnectsToSide(tile, tileRotation, 2, getObjectFromGUID(tileGrid[xIndex - 1][zIndex].tile_guid), tileGrid[xIndex - 1][zIndex].rotation)) and
    (not tileGridOccupied(xIndex, zIndex + 1) or tileConnectsToSide(tile, tileRotation, 3, getObjectFromGUID(tileGrid[xIndex][zIndex + 1].tile_guid), tileGrid[xIndex][zIndex + 1].rotation)) and
    (not tileGridOccupied(xIndex, zIndex - 1) or tileConnectsToSide(tile, tileRotation, 1, getObjectFromGUID(tileGrid[xIndex][zIndex - 1].tile_guid), tileGrid[xIndex][zIndex - 1].rotation))) then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_TILE_FEATURES_DONT_MATCH"}, activePlayers[currentPlayer]) end
        return false
    end

    if tileData.sides[1] == 'Abbey' and
    ((not tileGridOccupied(xIndex + 1, zIndex)) or (not tileGridOccupied(xIndex - 1, zIndex)) or (not tileGridOccupied(xIndex, zIndex + 1)) or (not tileGridOccupied(xIndex, zIndex - 1))) then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_ABBEY"}, activePlayers[currentPlayer]) end
        return false
    end
    if controlPanelSettings['CultTiles'] then
        local challengerTile = nil
        local challengedTile = nil
        local specialFeatures = tileData.specialFeatures
        if specialFeatures ~= nil then
            for _, feature in ipairs(specialFeatures) do
                if feature[1] == 'Cloister' or feature[1] == 'Shrine' then challengerTile = feature[1] end
                if feature[1] == 'Abbey' then challengerTile = 'Cloister' end
            end
        end
        if challengerTile ~= nil then
            if challengerTile == 'Cloister' then
                challengedTile = 'Shrine'
            else
                challengedTile = 'Cloister'
            end
            local numChallenger = 1
            local numChallenged = 0
            for x=-1, 1 do
                for z=-1, 1 do
                    if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                        local specialFeatures = getTileDataForTile(getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid)).specialFeatures
                        if specialFeatures ~= nil then
                            for _, feature in ipairs(specialFeatures) do
                                local adjacentFeature = feature[1]
                                if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                if adjacentFeature == challengedTile then
                                    numChallenged = numChallenged + 1
                                    for nested_x=-1, 1 do
                                        for nested_z=-1, 1 do
                                            if not (nested_x == 0 and nested_z == 0) and tileGridOccupied(xIndex + x + nested_x, zIndex + z + nested_z) then
                                                local nestedSpecialFeatures = getTileDataForTile(getObjectFromGUID(tileGrid[xIndex + x + nested_x][zIndex + z + nested_z].tile_guid)).specialFeatures
                                                if nestedSpecialFeatures ~= nil then
                                                    for _, nestedFeature in ipairs(nestedSpecialFeatures) do
                                                        local nestedAdjacentFeature = nestedFeature[1]
                                                        if nestedAdjacentFeature == 'Abbey' then nestedAdjacentFeature = 'Cloister' end
                                                        if nestedAdjacentFeature == challengerTile then
                                                            numChallenger = numChallenger + 1
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if numChallenged > 1 or numChallenger > 1 then
                if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_SHRINE_CLOISTER"}, activePlayers[currentPlayer]) end
                return false
            end
        end
    end
    --validate river piece
    local isStartingPiece = tileData.isStartingPiece
    if isStartingPiece then
        local hasRiver = false
        local riverHasConnection = false
        for i=1, 4 do
            if tileData.sides[(3 + i - tileRotation) % 4 + 1] == 'River' then
                hasRiver = true
                local diff = 0
                local x = xIndex
                local z = zIndex
                if i > 2 then diff = 1 else diff = -1 end
                if i % 2 == 0 then x = x + diff else z = z + diff end
                --if it has a river, then the following must be true for at least one of the sides
                if tileGridOccupied(x, z) and tileConnectsToSide(tile, tileRotation, i, getObjectFromGUID(tileGrid[x][z].tile_guid), tileGrid[x][z].rotation) then
                    riverHasConnection = true
                    --the following checks to see if this tile would create a "U-turn" such that the river folds back on itself
                    --this is illegal and can easily lead to issues
                    --Though technically illegal, it is possible to still make a river that folds back on itself.
                    if not controlPanelSettings["RiverAllowUTurns"] and ((tileData.sides[(3 + i + 1 - tileRotation) % 4 + 1] == 'River' and getTileDataForTile(getObjectFromGUID(tileGrid[x][z].tile_guid)).sides[(3 + i + 1 - tileGrid[x][z].rotation) % 4 + 1] == 'River') or
                    (tileData.sides[(3 + i + 3 - tileRotation) % 4 + 1] == 'River' and getTileDataForTile(getObjectFromGUID(tileGrid[x][z].tile_guid)).sides[(3 + i + 3 - tileGrid[x][z].rotation) % 4 + 1] == 'River')) then
                        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_RIVER_U_TURN"}, activePlayers[currentPlayer]) end
                        return false
                    end
                end
            end
        end
        if not controlPanelSettings["RiverAllowUnconnected"] and hasRiver and riverIsOpen() and not riverHasConnection then
            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_RIVER_UNCONNECTED"}, activePlayers[currentPlayer]) end
            return false
        end
    end
    return true
end

function isValidFigureLocation(newFigure, xIndex, zIndex, featureMapPosition, featureNum, verbose)
    local nameOfFeature = featureList[featureNum].nameOfFeature
    local numOpenings = featureList[featureNum].numOpenings
    if not (
        (xIndex == lastPlacedTileX and zIndex == lastPlacedTileZ) or
        (PnDIsMagicPortalAvailable() and table.contains(FOLLOWER_TYPES, newFigure.getVar('figureName'))) or
        newFigure.getVar('figureName') == 'Barn' or nameOfFeature == 'Tower Foundation' or string.sub(nameOfFeature,1,6) == 'Crown-'
        ) then
        if PnDIsUsedMagicPortalOnTile() and table.contains(FOLLOWER_TYPES, newFigure.getVar('figureName')) then
            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_MAGIC_PORTAL_USAGE_EXCEEDED"}, activePlayers[currentPlayer]) end
            return
        else
            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FIGURE_WRONG_TILE"}, activePlayers[currentPlayer]) end
            return
        end
    end
    if not PnDDragonIsValidLocation(newFigure, xIndex, zIndex, activePlayers[currentPlayer]) then
        return false
    end
    if nameOfFeature == 'River' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FIGURE_ON_RIVER"}, activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Carcassonne' or string.sub(nameOfFeature,1,8) == 'Quarter-' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_NOT_ALLOWED"}, activePlayers[currentPlayer]) end
        return false
    end
    if string.sub(nameOfFeature,1,6) == 'Flier-' then
        return flierIsValidFigureLocation(newFigure)
    end
    if nameOfFeature == 'Tower Foundation' then
        if not table.contains(MEEPLE_TYPES, newFigure.getVar('figureName')) and newFigure.getVar('figureName') ~= 'Tower' then
            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_TOWER_ILLEGAL_FIGURE"}, activePlayers[currentPlayer]) end
            return false
        else
            local hasTower = false
            for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
                local nestedXIndex, nestedZIndex, xPosition, zPosition = getFigureTileLocation(obj)
                if xIndex == nestedXIndex and zIndex == nestedZIndex then
                    if not tileGridOccupied(xIndex, zIndex) then
                        allErrorMessage("ERROR: Something went very wrong.", activePlayers[currentPlayer])
                        return false
                    end
                    local closestFeatureMapPosition = findClosestPosition(xIndex, zIndex, xPosition, zPosition)
                    if closestFeatureMapPosition == featureMapPosition and obj.getGUID() ~= newFigure.getGUID() then
                        if table.contains(MEEPLE_TYPES, obj.getVar('figureName')) then
                            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_TOWER_ALREADY_OCCUPIED"}, activePlayers[currentPlayer]) end
                            return false
                        elseif obj.getVar('figureName') == 'Tower' then
                            hasTower = true
                        elseif tostring(obj) == 'Card(Clone) (LuaGameObjectScript)' then
                            --it's the tile, we can ignore it
                        elseif obj.getVar('figureName') ~= GOLD_BAR_NAME then
                            if verbose then allErrorMessage("ERROR: There is an illegal piece in this tower location: " .. obj.getName(), activePlayers[currentPlayer]) end
                            return false
                        end
                    end
                end
            end
            if table.contains(MEEPLE_TYPES, newFigure.getVar('figureName')) and not hasTower then
                if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_TOWER_FIGURE_BEFORE_TOWER"}, activePlayers[currentPlayer]) end
                return false
            end
            return true
        end
    end
    if string.sub(nameOfFeature,1,6) == 'Crown-' then
        if not controlPanelSettings['WoFCrowns'] then
            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_WHEEL_CROWN_DISABLED"}, activePlayers[currentPlayer]) end
            return false
        end
        if not table.contains(MEEPLE_TYPES, newFigure.getVar('figureName')) then
            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_WHEEL_CROWN"}, activePlayers[currentPlayer]) end
            return false
        end
    end
    if newFigure.getVar('figureName') == 'Shepherd' and nameOfFeature ~= 'Field' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_SHEPHERD"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Abbot' and not (nameOfFeature == 'Garden' or nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey') then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_ABBOT"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') ~= 'Abbot' and nameOfFeature == 'Garden' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_GARDEN"}, activePlayers[currentPlayer]) end
        return false
    end
    if not TnBIsValidBuilderLocation(newFigure, nameOfFeature) then
        return false
    end
    if not TnBIsValidPigLocation(newFigure, nameOfFeature) then
        return false
    end
    if newFigure.getVar('figureName') == 'Mayor' and nameOfFeature ~= 'City' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_MAYOR"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Wagon' and nameOfFeature == 'Field' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_WAGON"}, activePlayers[currentPlayer]) end
        return false
    end
    if (nameOfFeature == 'Road' and controlPanelSettings['BaseDisableRoads']) or
        (nameOfFeature == 'City' and controlPanelSettings['BaseDisableCities']) or
        (nameOfFeature == 'Cloister' and controlPanelSettings['BaseDisableCloisters']) or
        (nameOfFeature == 'Field' and newFigure.getVar('figureName') ~= 'Shepherd' and controlPanelSettings['BaseDisableFarms']) then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FEATURE_DISABLED", {'{s1}', translate({nameOfFeature})}}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Barn' then
        if nameOfFeature ~= 'Field' or not AnMIsValidBarnLocation(featureMapPosition, xIndex, zIndex) then
            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_BARN"}, activePlayers[currentPlayer]) end
            return false
        end
    end
    if numOpenings == 0 and not (xIndex == lastPlacedTileX and zIndex == lastPlacedTileZ) and string.sub(nameOfFeature,1,6) ~= 'Crown-' and newFigure.getVar('figureName') ~= 'Barn' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_MAGIC_PORTAL"}, activePlayers[currentPlayer]) end
        return false
    end

    local numFollowers = 0
    local numCurrentPlayerFollowers = 0
    local numShepherds = 0
    local numBarns = 0

    if activeFigures[featureNum] ~= nil then
        for _, obj in ipairs(activeFigures[featureNum].followers) do
            if obj ~= newFigure then
                if table.contains(FOLLOWER_TYPES, obj.getVar('figureName')) then
                    numFollowers = numFollowers + 1
                    if obj.getVar('owner') == activePlayers[currentPlayer] then
                        numCurrentPlayerFollowers = numCurrentPlayerFollowers + 1
                    end
                end
            end
        end
        for _, obj in ipairs(activeFigures[featureNum].specialFigures) do
            if obj ~= newFigure then
                if obj.getVar('figureName') == 'Shepherd' then
                    numShepherds = numShepherds + 1
                elseif obj.getVar('figureName') == 'Barn' then
                    numBarns = numBarns + 1
                end
            end
        end
    end
    if not TnBIsValidBuilderParent(newFigure, numCurrentPlayerFollowers) then
        return false
    end
    if not TnBIsValidPigParent(newFigure, numCurrentPlayerFollowers) then
        return false
    end
    if (table.contains(FOLLOWER_TYPES, newFigure.getVar('figureName')) and numFollowers == 0 and numBarns == 0) or
        (newFigure.getVar('figureName') == 'Shepherd' and numShepherds == 0) or
        (newFigure.getVar('figureName') == 'Barn' and numBarns == 0) or
         TnBIsDependentFigure(newFigure) then
        return true
    else
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FEATURE_ALREADY_OCCUPIED"}, activePlayers[currentPlayer]) end
    end
    return false
end

function isValidCoCLocation(newFigure, featureNum, verbose)
    local nameOfFeature = featureList[featureNum].nameOfFeature

    if not (table.contains(FOLLOWER_TYPES, newFigure.getVar('figureName')) or newFigure.getVar('figureName') == 'Count') then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_ILLEGAL_FIGURE"}, activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Carcassonne' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_NOT_A_QUARTER"}, activePlayers[currentPlayer]) end
        return false
    end
    if string.sub(nameOfFeature,1,8) ~= 'Quarter-' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Abbot' and nameOfFeature ~= 'Quarter-Cathedral' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_ABBOT"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Mayor' and nameOfFeature ~= 'Quarter-Castle' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_MAYOR"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Wagon' and nameOfFeature == 'Quarter-Market' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_WAGON"}, activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Quarter-Blacksmith' and controlPanelSettings['BaseDisableRoads'] then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_ROADS_DISABLED"}, activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Quarter-Castle' and controlPanelSettings['BaseDisableCities'] then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_CITIES_DISABLED"}, activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Quarter-Market' and controlPanelSettings['BaseDisableFields'] then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_FIELDS_DISABLED"}, activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Quarter-Cathedral' and controlPanelSettings['BaseDisableCloisters'] then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_CLOISTERS_DISABLED"}, activePlayers[currentPlayer]) end
        return false
    end
    return true
end

function isValidLocationFromCoC(newFigure, featureNum, verbose)
    local nameOfFeature = featureList[featureNum].nameOfFeature
    local numOpenings = featureList[featureNum].numOpenings
    if carcassonneFigures[newFigure.getVar('owner')] == nil or carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] == nil then
        if verbose then allErrorMessage({"MESSAGE_COC_FROM_CITY_ILLEGAL_FIGURE"}, activePlayers[currentMiniTurn]) end
        return false
    end

    local validFeature
    if carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] == 'Blacksmith' then
        validFeature = 'Road'
    elseif carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] == 'Castle' then
        validFeature = 'City'
    elseif carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] == 'Cathedral' then
        validFeature = 'Cloister'
    elseif carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] == 'Market' then
        validFeature = 'Field'
    else
        if verbose then allErrorMessage("Error: Unrecognized feature: " .. carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] .. " Please tell the dev.", activePlayers[currentMiniTurn]) end
        return false
    end

    if nameOfFeature == 'Abbey' or nameOfFeature == 'Shrine' then
        nameOfFeature = 'Cloister'
    end

    if nameOfFeature ~= validFeature then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_FROM_WRONG_QUARTER", {'{f1}', carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()]}, {'{s1}', validFeature}}, activePlayers[currentMiniTurn]) end
        return false
    end

    if nameOfFeature == 'Tower Foundation' then
        --does this need a special error message? I think it's obvious that a tower can't be "completed"
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_COMPLETED_ONLY"}, activePlayers[currentMiniTurn]) end
        return false
    end

    if numOpenings ~= 0 and carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] ~= 'Market' and turnState ~= 'game over - prompt moving from carcassonne' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_COMPLETED_ONLY"}, activePlayers[currentMiniTurn]) end
        return false
    end
    if numOpenings == 0 and carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] ~= 'Market' and turnState == 'game over - prompt moving from carcassonne' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_END_GAME_INCOMPLETE_ONLY"}, activePlayers[currentMiniTurn]) end
        return false
    end

    if not gameIsActive() then return true end

    local tileData = getTileDataForTile(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid))
    local specialFeatures = tileData.specialFeatures

    local isAbbey = false
    if specialFeatures ~= nil then
        for _, specialFeature in ipairs(specialFeatures) do
            if specialFeature[1] == 'Abbey' then
                isAbbey = true
            end
        end
    end

    local positionsToVisit = {}
    if specialFeatures ~= nil then
        for specialFeatureNum, specialFeature in pairs(specialFeatures) do
            if specialFeature[3] ~= nil then
                table.insert(positionsToVisit, specialFeatureNum+12)
            end
        end
    end
    for featureMapPosition=1, 12 do
        table.insert(positionsToVisit, featureMapPosition)
    end
    for _, featureMapPosition in ipairs(positionsToVisit) do
        --find if featureNum is one of the features that was added to by the last tile placed
        local nestedFeatureNum = nil
        if isAbbey and featureMapPosition < 13 then
            local connectedFeatureMapPosition, connectedX, connectedZ = getConnectingFeatureMapPosition(lastPlacedTileX, lastPlacedTileZ, featureMapPosition, TILE_STANDARD_ROTATION)
            nestedFeatureNum = getFeatureNumAt(connectedX, connectedZ, connectedFeatureMapPosition)
        else --Note that this includes the Abbey itself if isAbbey == true and featureMapPosition == 13. This is intended.
            nestedFeatureNum = getFeatureNumAt(lastPlacedTileX, lastPlacedTileZ, featureMapPosition)
        end
        if nestedFeatureNum ~= nil then
            if nameOfFeature == 'Field' and table.contains(barnFeatureNumbers, featureNum) then
                return true
            elseif nameOfFeature ~= 'Field' and featureNum == nestedFeatureNum then
                return true
            end
        end
    end

    --find if a proximity feature completed by the last tile placed
    if nameOfFeature == 'Cloister' then --Note up above Abbeys and Shrines are given the name 'Cloister'. They are included in this logic
        for _, offset in ipairs(DIAGONAL_DELTA) do
            local neighborX = lastPlacedTileX + offset.x
            local neighborZ = lastPlacedTileZ + offset.z
            if tileGridOccupied(neighborX, neighborZ) then
                for _, neighborFeatureNum in pairs(tileGrid[neighborX][neighborZ].featureMap) do
                    if featureNum == neighborFeatureNum then
                        return true
                    end
                end
            end
        end
    end

    if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_LAST_TILE_ONLY"}, activePlayers[currentMiniTurn]) end
    return false
end
